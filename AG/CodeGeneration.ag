module {AG.CodeGeneration} {} {
import Hisp
import SKI
import qualified Data.Set as S
}

include "AG/Hisp.ag"
include "AG/SKI.ag"

attr HispExpr
    syn code :: {SKI @a}

attr SKI
    inh var :: {@a}
    syn abs :: {SKI @a}
    syn uses use {`S.union`} {S.empty} :: {S.Set @a}
    syn copy :: self

sem Ord {a}, Eq {a} => HispExpr
    | Variable loc.code = Name @name
    | Number   loc.code = Constant @value
    | Application lhs.code = @f.code `App` @x.code
    | Lambda   loc.code = abstract @expr.code @x

sem Ord {a}, Eq {a} => SKI
    | * - Name Constant App Number
                lhs.abs = K `App` @loc.copy
    | Name      lhs.abs = if @lhs.var == @x then I else K `App` @loc.copy
                lhs.uses = S.singleton @x
    | Constant  lhs.abs = K `App` @loc.copy
    | App       lhs.abs = case (@lhs.var `S.member` @x.uses, @lhs.var `S.member` @y.uses) of
                                  (True, True) -> S `App` @x.abs `App` @y.abs
                                  (True, False) -> L `App` @x.abs `App` @y.copy
                                  (False, True) -> R `App` @x.copy `App` @y.abs
                                  (False, False) -> K `App` (@x.copy `App` @y.copy)

{
abstract expr var = abs_Syn_SKI $ wrap_SKI (sem_SKI expr) (Inh_SKI var)

compile expr = code_Syn_HispExpr $ wrap_HispExpr (sem_HispExpr expr) Inh_HispExpr
}
